{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project description Temporal networks offer valuable insights into dynamic complex systems, capturing the evolving nature of social, biological, and technological interactions. Community structure is a critical feature of real networks, revealing the internal organization of nodes. Dynamic community detection algorithms uncover strongly connected node groups, unveiling hidden temporal patterns and community dynamics in temporal networks. However, evaluating the performance of these algorithms remains a challenge. A well-established method is to use tests that rely on synthetic graphs. Yet, this approach does not suit temporal networks with instantaneous edges and continuous time domains, known as link streams. To address this gap, we propose a novel benchmark comprising predefined communities that simulate synthetic modular link streams. Mosaic-Benchmark is a library for creating modular link streams for testing dynamic community detection algorithms in complex temporal networks: it creates communities, visualises them and exports the network to csv files. Citation If you use our algorithm, please cite the following works: paper Dependencies Mosaic is written in Python and requires the following package to run: python>=3.8 Pandas tqdm Numpy Matplotlib itertools Tutorial Check out the official tutorial to get started!","title":"Project description"},{"location":"#project-description","text":"Temporal networks offer valuable insights into dynamic complex systems, capturing the evolving nature of social, biological, and technological interactions. Community structure is a critical feature of real networks, revealing the internal organization of nodes. Dynamic community detection algorithms uncover strongly connected node groups, unveiling hidden temporal patterns and community dynamics in temporal networks. However, evaluating the performance of these algorithms remains a challenge. A well-established method is to use tests that rely on synthetic graphs. Yet, this approach does not suit temporal networks with instantaneous edges and continuous time domains, known as link streams. To address this gap, we propose a novel benchmark comprising predefined communities that simulate synthetic modular link streams. Mosaic-Benchmark is a library for creating modular link streams for testing dynamic community detection algorithms in complex temporal networks: it creates communities, visualises them and exports the network to csv files.","title":"Project description"},{"location":"#citation","text":"If you use our algorithm, please cite the following works: paper","title":"Citation"},{"location":"#dependencies","text":"Mosaic is written in Python and requires the following package to run: python>=3.8 Pandas tqdm Numpy Matplotlib itertools","title":"Dependencies"},{"location":"#tutorial","text":"Check out the official tutorial to get started!","title":"Tutorial"},{"location":"installing/","text":"Installing Mosaic-Benchmark Mosaic-Benchmark requires python>=3.8. To install the latest version of our library just download (or clone) the current project, open a terminal and run the following commands: pip install -r requirements.txt pip install . Alternatively use pip pip install mosaic-benchmark You can install the development version directly from the GitHub repository with pip install git+https://github.com/YasAsgari/Mosaic-benchmark.git","title":"Installing Mosaic-Benchmark"},{"location":"installing/#installing-mosaic-benchmark","text":"Mosaic-Benchmark requires python>=3.8. To install the latest version of our library just download (or clone) the current project, open a terminal and run the following commands: pip install -r requirements.txt pip install . Alternatively use pip pip install mosaic-benchmark You can install the development version directly from the GitHub repository with pip install git+https://github.com/YasAsgari/Mosaic-benchmark.git","title":"Installing Mosaic-Benchmark"},{"location":"tutorial/","text":"Quick Start Mosaic-Benchmark is a python library that allows to create modular linkstreams which can be used in format. Tutorial Creating modular linkstreams using Mosaic-Benchmark is easy as this: from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.generate_edges(1,0,1,0) M.export('Address:\\\\') Of course, you can choose among all the algorithms available for scenario description(taking care of specifying the correct parameters): in any case, you'll get as a result a '.csv' file for temporal edges and communities as '.npy' file. You can also perform the action of emptying mosaics using: M.empty_mosaics(gamma=0.5) Or you can rewire the edges: M.rewiring_noise(eta=0.1) Moreover, you can also visualize communities. M.plot() I know, plain tutorials are overrated: if you want to explore Mosaic-benchmark functionalities, please start playing around with our interactive Google Colab Notebook ! FAQ Q1. I developed a novel Scenario description or generating edges method and I would like to see it integrated in Mosaic-Benchmark . What should I do? A1. That's great! Just open an issue on the project GitHub briefly describing the method (provide a link to the paper where it has been firstly introduced) and links to a python implementation (if available). We'll came back to you as soon as possible to discuss the next steps. Q2. Can you add method XXX to your library? A2. It depends. Do you have a link to a python implementation/are you willing to help us in implementing it? If so, that's perfect. If not, well... everything is possible but it is likely that it will require some time.","title":"Quick Start"},{"location":"tutorial/#quick-start","text":"Mosaic-Benchmark is a python library that allows to create modular linkstreams which can be used in format.","title":"Quick Start"},{"location":"tutorial/#tutorial","text":"Creating modular linkstreams using Mosaic-Benchmark is easy as this: from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.generate_edges(1,0,1,0) M.export('Address:\\\\') Of course, you can choose among all the algorithms available for scenario description(taking care of specifying the correct parameters): in any case, you'll get as a result a '.csv' file for temporal edges and communities as '.npy' file. You can also perform the action of emptying mosaics using: M.empty_mosaics(gamma=0.5) Or you can rewire the edges: M.rewiring_noise(eta=0.1) Moreover, you can also visualize communities. M.plot() I know, plain tutorials are overrated: if you want to explore Mosaic-benchmark functionalities, please start playing around with our interactive Google Colab Notebook !","title":"Tutorial"},{"location":"tutorial/#faq","text":"Q1. I developed a novel Scenario description or generating edges method and I would like to see it integrated in Mosaic-Benchmark . What should I do? A1. That's great! Just open an issue on the project GitHub briefly describing the method (provide a link to the paper where it has been firstly introduced) and links to a python implementation (if available). We'll came back to you as soon as possible to discuss the next steps. Q2. Can you add method XXX to your library? A2. It depends. Do you have a link to a python implementation/are you willing to help us in implementing it? If so, that's perfect. If not, well... everything is possible but it is likely that it will require some time.","title":"FAQ"},{"location":"Methods/%20initialization/","text":"Initialization For unifying all the function we have created a Python class named ModularLinkStream which is very easy to access. The parameters for initializing is: Name Type Description number_of_nodes Integer Total number of nodes in the network. t_start Float Starting time of the link stream. t_end Float Ending time of the link stream. Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) print('Starting time', M.t_start) print('Ending time', M.t_end) print('Number of nodes', M.number_of_nodes) print('Nodes' , M.nodes) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) print('Number of communities', M.number_of_communities) #Generate edges M.generate_edges(1,1,1,1) #Access to edges: M.temporal_edges","title":"Initialization"},{"location":"Methods/%20initialization/#initialization","text":"For unifying all the function we have created a Python class named ModularLinkStream which is very easy to access. The parameters for initializing is: Name Type Description number_of_nodes Integer Total number of nodes in the network. t_start Float Starting time of the link stream. t_end Float Ending time of the link stream.","title":"Initialization"},{"location":"Methods/%20initialization/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) print('Starting time', M.t_start) print('Ending time', M.t_end) print('Number of nodes', M.number_of_nodes) print('Nodes' , M.nodes) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) print('Number of communities', M.number_of_communities) #Generate edges M.generate_edges(1,1,1,1) #Access to edges: M.temporal_edges","title":"Example"},{"location":"Methods/community/","text":"Mosaic Community To extend the definition of communities for temporal networks, we define a mosaic as a community which contains nodes interacting in the time frame. Name Type Description number_of_nodes Integer A list containing nodes that belong to the mosaic. t_start Float Starting time of the mosaic. t_end Float Ending time of the mosaic. Example: from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) mos1=M.communities['c1'] print(f'Nodes={mos1.nodes}---Time:({mos1.t_start},{mos1.t_end})')","title":"Mosaic Community"},{"location":"Methods/community/#mosaic-community","text":"To extend the definition of communities for temporal networks, we define a mosaic as a community which contains nodes interacting in the time frame. Name Type Description number_of_nodes Integer A list containing nodes that belong to the mosaic. t_start Float Starting time of the mosaic. t_end Float Ending time of the mosaic.","title":"Mosaic Community"},{"location":"Methods/community/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) mos1=M.communities['c1'] print(f'Nodes={mos1.nodes}---Time:({mos1.t_start},{mos1.t_end})')","title":"Example:"},{"location":"Methods/export/","text":"Export Mosaic Benchmark can export two different types of files. *-edges.csv : Edgelist representation of the generated graph. One line for each edge in link stream. *-communities.npy : community description. The syntax of each class of output files is the following: Communities A community is descibed as: community_id [node1, node2, node3, ..., nodeN] stating_time ending_time Interactions One edge per line with the syntax: time node1 node2 Where: time identify the time in which the interaction occurs. node1 and node2 are interaction endpoints. Example: 1.5 2 4 3 4 8 Code def export(self, address: str): Exports the link stream data to files. Parameters: - address: Address for exporting data. Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.snap_shot_scenario(number_of_slices=2) M.generate_edges(1,1,1,1) #Exporting M.export('Address://scenario1')","title":"Export"},{"location":"Methods/export/#export","text":"Mosaic Benchmark can export two different types of files. *-edges.csv : Edgelist representation of the generated graph. One line for each edge in link stream. *-communities.npy : community description. The syntax of each class of output files is the following: Communities A community is descibed as: community_id [node1, node2, node3, ..., nodeN] stating_time ending_time Interactions One edge per line with the syntax: time node1 node2 Where: time identify the time in which the interaction occurs. node1 and node2 are interaction endpoints. Example: 1.5 2 4 3 4 8","title":"Export"},{"location":"Methods/export/#code","text":"def export(self, address: str): Exports the link stream data to files. Parameters: - address: Address for exporting data.","title":"Code"},{"location":"Methods/export/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.snap_shot_scenario(number_of_slices=2) M.generate_edges(1,1,1,1) #Exporting M.export('Address://scenario1')","title":"Example"},{"location":"Methods/generating_edges/","text":"Generating edges","title":"Generating edges"},{"location":"Methods/generating_edges/#generating-edges","text":"","title":"Generating edges"},{"location":"Methods/scenario_description/","text":"Scenario description","title":"Scenario description"},{"location":"Methods/scenario_description/#scenario-description","text":"","title":"Scenario description"},{"location":"Methods/visualisation/","text":"Visualisation","title":"Visualisation"},{"location":"Methods/visualisation/#visualisation","text":"","title":"Visualisation"}]}