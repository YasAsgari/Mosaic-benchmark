{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project description Temporal networks offer valuable insights into dynamic complex systems, capturing the evolving nature of social, biological, and technological interactions. Community structure is a critical feature of real networks, revealing the internal organization of nodes. Dynamic community detection algorithms uncover strongly connected node groups, unveiling hidden temporal patterns and community dynamics in temporal networks. However, evaluating the performance of these algorithms remains a challenge. A well-established method is to use tests that rely on synthetic graphs. Yet, this approach does not suit temporal networks with instantaneous edges and continuous time domains, known as link streams. To address this gap, we propose a novel benchmark comprising predefined communities that simulate synthetic modular link streams. Mosaic-Benchmark is a library for creating modular link streams for testing dynamic community detection algorithms in complex temporal networks: it creates communities, visualises them and exports the network to csv files. Citation If you use our algorithm, please cite the following works: paper Dependencies Mosaic is written in Python and requires the following package to run: python>=3.8 Pandas tqdm Numpy Matplotlib itertools Tutorial Check out the official tutorial to get started!","title":"Project description"},{"location":"#project-description","text":"Temporal networks offer valuable insights into dynamic complex systems, capturing the evolving nature of social, biological, and technological interactions. Community structure is a critical feature of real networks, revealing the internal organization of nodes. Dynamic community detection algorithms uncover strongly connected node groups, unveiling hidden temporal patterns and community dynamics in temporal networks. However, evaluating the performance of these algorithms remains a challenge. A well-established method is to use tests that rely on synthetic graphs. Yet, this approach does not suit temporal networks with instantaneous edges and continuous time domains, known as link streams. To address this gap, we propose a novel benchmark comprising predefined communities that simulate synthetic modular link streams. Mosaic-Benchmark is a library for creating modular link streams for testing dynamic community detection algorithms in complex temporal networks: it creates communities, visualises them and exports the network to csv files.","title":"Project description"},{"location":"#citation","text":"If you use our algorithm, please cite the following works: paper","title":"Citation"},{"location":"#dependencies","text":"Mosaic is written in Python and requires the following package to run: python>=3.8 Pandas tqdm Numpy Matplotlib itertools","title":"Dependencies"},{"location":"#tutorial","text":"Check out the official tutorial to get started!","title":"Tutorial"},{"location":"installing/","text":"Installing Mosaic-Benchmark Mosaic-Benchmark requires python>=3.8. To install the latest version of our library just download (or clone) the current project, open a terminal and run the following commands: pip install -r requirements.txt pip install . Alternatively use pip pip install mosaic-benchmark You can install the development version directly from the GitHub repository with pip install git+https://github.com/YasAsgari/Mosaic-benchmark.git","title":"Installing Mosaic-Benchmark"},{"location":"installing/#installing-mosaic-benchmark","text":"Mosaic-Benchmark requires python>=3.8. To install the latest version of our library just download (or clone) the current project, open a terminal and run the following commands: pip install -r requirements.txt pip install . Alternatively use pip pip install mosaic-benchmark You can install the development version directly from the GitHub repository with pip install git+https://github.com/YasAsgari/Mosaic-benchmark.git","title":"Installing Mosaic-Benchmark"},{"location":"tutorial/","text":"Quick Start Mosaic-Benchmark is a python library that allows to create modular linkstreams which can be used in format. Tutorial Creating modular linkstreams using Mosaic-Benchmark is easy as this: from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.generate_edges(1,0,1,0) M.export('Address:\\\\') Of course, you can choose among all the algorithms available for scenario description(taking care of specifying the correct parameters): in any case, you'll get as a result a '.csv' file for temporal edges and communities as '.npy' file. You can also perform the action of emptying mosaics using: M.empty_mosaics(gamma=0.5) Or you can rewire the edges: M.rewiring_noise(eta=0.1) Moreover, you can also visualize communities. M.plot() I know, plain tutorials are overrated: if you want to explore Mosaic-benchmark functionalities, please start playing around with our interactive Google Colab Notebook ! FAQ Q1. I developed a novel Scenario description or generating edges method and I would like to see it integrated in Mosaic-Benchmark . What should I do? A1. That's great! Just open an issue on the project GitHub briefly describing the method (provide a link to the paper where it has been firstly introduced) and links to a python implementation (if available). We'll came back to you as soon as possible to discuss the next steps. Q2. Can you add method XXX to your library? A2. It depends. Do you have a link to a python implementation/are you willing to help us in implementing it? If so, that's perfect. If not, well... everything is possible but it is likely that it will require some time.","title":"Quick Start"},{"location":"tutorial/#quick-start","text":"Mosaic-Benchmark is a python library that allows to create modular linkstreams which can be used in format.","title":"Quick Start"},{"location":"tutorial/#tutorial","text":"Creating modular linkstreams using Mosaic-Benchmark is easy as this: from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.generate_edges(1,0,1,0) M.export('Address:\\\\') Of course, you can choose among all the algorithms available for scenario description(taking care of specifying the correct parameters): in any case, you'll get as a result a '.csv' file for temporal edges and communities as '.npy' file. You can also perform the action of emptying mosaics using: M.empty_mosaics(gamma=0.5) Or you can rewire the edges: M.rewiring_noise(eta=0.1) Moreover, you can also visualize communities. M.plot() I know, plain tutorials are overrated: if you want to explore Mosaic-benchmark functionalities, please start playing around with our interactive Google Colab Notebook !","title":"Tutorial"},{"location":"tutorial/#faq","text":"Q1. I developed a novel Scenario description or generating edges method and I would like to see it integrated in Mosaic-Benchmark . What should I do? A1. That's great! Just open an issue on the project GitHub briefly describing the method (provide a link to the paper where it has been firstly introduced) and links to a python implementation (if available). We'll came back to you as soon as possible to discuss the next steps. Q2. Can you add method XXX to your library? A2. It depends. Do you have a link to a python implementation/are you willing to help us in implementing it? If so, that's perfect. If not, well... everything is possible but it is likely that it will require some time.","title":"FAQ"},{"location":"Methods/%20initialization/","text":"Initialization For unifying all the function we have created a Python class named ModularLinkStream which is very easy to access. The parameters for initializing is: Name Type Description number_of_nodes Integer Total number of nodes in the network. t_start Float Starting time of the link stream. t_end Float Ending time of the link stream. Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) print('Starting time', M.t_start) print('Ending time', M.t_end) print('Number of nodes', M.number_of_nodes) print('Nodes' , M.nodes) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) print('Number of communities', M.number_of_communities) #Generate edges M.generate_edges(1,1,1,1) #Access to edges: M.temporal_edges","title":"Initialization"},{"location":"Methods/%20initialization/#initialization","text":"For unifying all the function we have created a Python class named ModularLinkStream which is very easy to access. The parameters for initializing is: Name Type Description number_of_nodes Integer Total number of nodes in the network. t_start Float Starting time of the link stream. t_end Float Ending time of the link stream.","title":"Initialization"},{"location":"Methods/%20initialization/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) print('Starting time', M.t_start) print('Ending time', M.t_end) print('Number of nodes', M.number_of_nodes) print('Nodes' , M.nodes) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) print('Number of communities', M.number_of_communities) #Generate edges M.generate_edges(1,1,1,1) #Access to edges: M.temporal_edges","title":"Example"},{"location":"Methods/community/","text":"Mosaic Community To extend the definition of communities for temporal networks, we define a mosaic as a community which contains nodes interacting in the time frame. Name Type Description number_of_nodes Integer A list containing nodes that belong to the mosaic. t_start Float Starting time of the mosaic. t_end Float Ending time of the mosaic. Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) mos1=M.communities['c1'] print(f'Nodes={mos1.nodes}---Time:({mos1.t_start},{mos1.t_end})')","title":"Mosaic Community"},{"location":"Methods/community/#mosaic-community","text":"To extend the definition of communities for temporal networks, we define a mosaic as a community which contains nodes interacting in the time frame. Name Type Description number_of_nodes Integer A list containing nodes that belong to the mosaic. t_start Float Starting time of the mosaic. t_end Float Ending time of the mosaic.","title":"Mosaic Community"},{"location":"Methods/community/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=100, t_start=0,t_end=100) #Creating some communities M.snap_shot_scenario(number_of_slices=2) print('Communities', M.communities) mos1=M.communities['c1'] print(f'Nodes={mos1.nodes}---Time:({mos1.t_start},{mos1.t_end})')","title":"Example"},{"location":"Methods/export/","text":"Export Mosaic Benchmark can export two different types of files. *-edges.csv : Edgelist representation of the generated graph. One line for each edge in link stream. *-communities.npy : community description. The syntax of each class of output files is the following: Communities A community is descibed as: community_id [node1, node2, node3, ..., nodeN] stating_time ending_time Interactions One edge per line with the syntax: time node1 node2 Where: time identify the time in which the interaction occurs. node1 and node2 are interaction endpoints. Example: 1.5 2 4 3 4 8 Code def export(self, address: str): Exports the link stream data to files. Parameters: - address: Address for exporting data. Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.snap_shot_scenario(number_of_slices=2) M.generate_edges(1,1,1,1) #Exporting M.export('Address://scenario1')","title":"Export"},{"location":"Methods/export/#export","text":"Mosaic Benchmark can export two different types of files. *-edges.csv : Edgelist representation of the generated graph. One line for each edge in link stream. *-communities.npy : community description. The syntax of each class of output files is the following: Communities A community is descibed as: community_id [node1, node2, node3, ..., nodeN] stating_time ending_time Interactions One edge per line with the syntax: time node1 node2 Where: time identify the time in which the interaction occurs. node1 and node2 are interaction endpoints. Example: 1.5 2 4 3 4 8","title":"Export"},{"location":"Methods/export/#code","text":"def export(self, address: str): Exports the link stream data to files. Parameters: - address: Address for exporting data.","title":"Code"},{"location":"Methods/export/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.snap_shot_scenario(number_of_slices=2) M.generate_edges(1,1,1,1) #Exporting M.export('Address://scenario1')","title":"Example"},{"location":"Methods/generating_edges/","text":"Generating edges This library generate edges in a modular structure based on the paper ... . Procedure It follows a two step process: Generating edges inside communities Generating edges between communities Each of these steps, also follow two subsequent processes: Creating backbone connectivity network for contributing nodes Add a temporal dimension to this static network using poisson point process. For the first step, the parameters are explained as below: Backbone connectivity network parameters Name Type Description alpha Float [0.5,1): defines the internal density coefficient beta Float [0,1]: related to community identifialbility For the second step, the arguments are discussed below: Poisson point process parameters Name Type Description lambda_in Float Rate of poisson process for generating temporal edges inside communities lambda_out Float Rate of poisson process for generating temporal edges betweek communities Rewiring noise Inorder to add imperfections to our linkstream, we introduced a rewiring noise which can be used after the edge generation procedure. It has only one paramter: Name Type Description eta Float [0,1]: rewiring noise probability Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) #Full clique inside, No edges outside in backbone connectivity network M.generate_edges(1,0,1,0) #Full clique inside and outside in backbone connectivity network (equal rates) M.clear_edges() M.generate_edges(1,1,1,1) #Full clique inside and outside in backbone connectivity network (dissimilar rates) M.clear_edges() M.generate_edges(1,1,1,0.01) # Signifact inside and rare outside in backbone connectivity network (similar rates) M.clear_edges() M.generate_edges(0.8,0.1,1,1) Becarefull that the function gets the attribute with this order: generate_edges(alpha, beta, lambda_in, lambda_out)","title":"Generating edges"},{"location":"Methods/generating_edges/#generating-edges","text":"This library generate edges in a modular structure based on the paper ... .","title":"Generating edges"},{"location":"Methods/generating_edges/#procedure","text":"It follows a two step process: Generating edges inside communities Generating edges between communities Each of these steps, also follow two subsequent processes: Creating backbone connectivity network for contributing nodes Add a temporal dimension to this static network using poisson point process. For the first step, the parameters are explained as below: Backbone connectivity network parameters Name Type Description alpha Float [0.5,1): defines the internal density coefficient beta Float [0,1]: related to community identifialbility For the second step, the arguments are discussed below: Poisson point process parameters Name Type Description lambda_in Float Rate of poisson process for generating temporal edges inside communities lambda_out Float Rate of poisson process for generating temporal edges betweek communities","title":"Procedure"},{"location":"Methods/generating_edges/#rewiring-noise","text":"Inorder to add imperfections to our linkstream, we introduced a rewiring noise which can be used after the edge generation procedure. It has only one paramter: Name Type Description eta Float [0,1]: rewiring noise probability","title":"Rewiring noise"},{"location":"Methods/generating_edges/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) #Full clique inside, No edges outside in backbone connectivity network M.generate_edges(1,0,1,0) #Full clique inside and outside in backbone connectivity network (equal rates) M.clear_edges() M.generate_edges(1,1,1,1) #Full clique inside and outside in backbone connectivity network (dissimilar rates) M.clear_edges() M.generate_edges(1,1,1,0.01) # Signifact inside and rare outside in backbone connectivity network (similar rates) M.clear_edges() M.generate_edges(0.8,0.1,1,1) Becarefull that the function gets the attribute with this order: generate_edges(alpha, beta, lambda_in, lambda_out)","title":"Example"},{"location":"Methods/scenario_description/","text":"Scenario description As explained in the paper, we have implemented three different methods for generating the communities in this library. Methods Ad-hoc scenario: The experimenter designs the communities based on their research questions. Snapshots: It helps us to have snapshots (with fixed or varying windowsize) so that the edges inside have a continuous time occurence. Random: A function that generates approximately a number of communities, different in size of nodes and time domains. Ad-hoc scenario example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.communities The parameters are: Name Type Description nodes List list of Integer indices inside a community t_start Float Starting time for community t_end Float Ending time for community Snapshot scenario example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) #Varying windowsizes M.snap_shot_scenario(3, fixed=False) print('varying',M.communities) #Fixed windowsizes M.clear_communities() M.snap_shot_scenario(3, fixed=True) print('fixed',M.communities) The parameters are: Name Type Description number_of_slices int The number of time intervals to divide the scenario into. fixed bool, optional If True, evenly divides time intervals; if False, varies interval length. Default is True. Random scenario example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.random_scenario(3) M.communities The parameters are: Name Type Description approx_order_of_communities: int it gives an approximate number of communities Note that the algorithm filters communities with less 2 nodes. Emptying Mosaic As described in the paper, we can empty the mosaics randomly based on our need to create a more realistic scenario. To do so, we can use the method named empty_mosaics which has only one parameter which is the probability of emptying which is called gamma . Random scenario example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=100) M.random_scenario(40) print('before', len(M.communities)) #Emptying M.empty_mosaics(gamma=0.5) print('after', len(M.communities))","title":"Scenario description"},{"location":"Methods/scenario_description/#scenario-description","text":"As explained in the paper, we have implemented three different methods for generating the communities in this library.","title":"Scenario description"},{"location":"Methods/scenario_description/#methods","text":"Ad-hoc scenario: The experimenter designs the communities based on their research questions. Snapshots: It helps us to have snapshots (with fixed or varying windowsize) so that the edges inside have a continuous time occurence. Random: A function that generates approximately a number of communities, different in size of nodes and time domains.","title":"Methods"},{"location":"Methods/scenario_description/#ad-hoc-scenario-example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.add_community([0,1,2,3,4],0,4) M.add_community([5,6,7,8,9],0,4) M.communities The parameters are: Name Type Description nodes List list of Integer indices inside a community t_start Float Starting time for community t_end Float Ending time for community","title":"Ad-hoc scenario example"},{"location":"Methods/scenario_description/#snapshot-scenario-example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) #Varying windowsizes M.snap_shot_scenario(3, fixed=False) print('varying',M.communities) #Fixed windowsizes M.clear_communities() M.snap_shot_scenario(3, fixed=True) print('fixed',M.communities) The parameters are: Name Type Description number_of_slices int The number of time intervals to divide the scenario into. fixed bool, optional If True, evenly divides time intervals; if False, varies interval length. Default is True.","title":"Snapshot scenario example"},{"location":"Methods/scenario_description/#random-scenario-example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=4) M.random_scenario(3) M.communities The parameters are: Name Type Description approx_order_of_communities: int it gives an approximate number of communities Note that the algorithm filters communities with less 2 nodes.","title":"Random scenario example"},{"location":"Methods/scenario_description/#emptying-mosaic","text":"As described in the paper, we can empty the mosaics randomly based on our need to create a more realistic scenario. To do so, we can use the method named empty_mosaics which has only one parameter which is the probability of emptying which is called gamma .","title":"Emptying Mosaic"},{"location":"Methods/scenario_description/#random-scenario-example_1","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=10, t_start=0,t_end=100) M.random_scenario(40) print('before', len(M.communities)) #Emptying M.empty_mosaics(gamma=0.5) print('after', len(M.communities))","title":"Random scenario example"},{"location":"Methods/visualisation/","text":"Visualisation Inorder to visualize the communities, we have provided a function that shows different communities. for better visualisations regarding the linkstreams, use the tnetwork ! Example from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=20, t_start=0,t_end=10) M.snap_shot_scenario(number_of_slices=4, fixed=False) #Visualize M.plot()","title":"Visualisation"},{"location":"Methods/visualisation/#visualisation","text":"Inorder to visualize the communities, we have provided a function that shows different communities. for better visualisations regarding the linkstreams, use the tnetwork !","title":"Visualisation"},{"location":"Methods/visualisation/#example","text":"from mosaic_benchmark import ModularLinkStream M=ModularLinkStream(number_of_nodes=20, t_start=0,t_end=10) M.snap_shot_scenario(number_of_slices=4, fixed=False) #Visualize M.plot()","title":"Example"}]}